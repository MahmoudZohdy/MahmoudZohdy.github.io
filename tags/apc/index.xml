<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>APC on Security Blog</title>
    <link>https://MahmoudZohdy.github.io/tags/apc/</link>
    <description>Recent content in APC on Security Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://MahmoudZohdy.github.io/tags/apc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Asynchronous Procedure Calls (APC) Enumeration</title>
      <link>https://MahmoudZohdy.github.io/posts/practical_reverse_engineering/apcenumeration/</link>
      <pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MahmoudZohdy.github.io/posts/practical_reverse_engineering/apcenumeration/</guid>
      <description>In this Blog I will explain my approach for solving one of the exercises from Practical Reverse Engineering Book, which is enumerating kernel/user Asynchronous Procedure Calls (APC) of a process.
So I started Reverse Engineering Some of the APC related functions, creating windows kernel driver that uses APC in different situation and use Windbg to add breakpoint on the APC callback functions to see how it is dispatched, plus Reading lots of blogs and documentation on how APC is working and how it is dispatched</description>
    </item>
    
  </channel>
</rss>
