<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Security Blog</title>
    <link>https://MahmoudZohdy.github.io/</link>
    <description>Recent content on Security Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://MahmoudZohdy.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>New BlackCat Driver Reverse Engineering</title>
      <link>https://MahmoudZohdy.github.io/posts/blackcat_driver/</link>
      <pubDate>Tue, 02 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://MahmoudZohdy.github.io/posts/blackcat_driver/</guid>
      <description>In this Blog I will explain my approach for solving one of the exercises from Practical Reverse Engineering Book, which is enumerating kernel/user Asynchronous Procedure Calls (APC) of a process.
So I started Reverse Engineering Some of the APC related functions, creating windows kernel driver that uses APC in different situation and use Windbg to add breakpoint on the APC callback functions to see how it is dispatched, plus Reading lots of blogs and documentation on how APC is working and how it is dispatched</description>
    </item>
    
    <item>
      <title>Development</title>
      <link>https://MahmoudZohdy.github.io/development/</link>
      <pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MahmoudZohdy.github.io/development/</guid>
      <description> Asynchronous Procedure Calls (APC) Enumeration Loaded Drivers Enumeration </description>
    </item>
    
    <item>
      <title>Loaded Drivers Enumeration</title>
      <link>https://MahmoudZohdy.github.io/posts/practical_reverse_engineering/enumerate_loaded_drivers_every_10sec/</link>
      <pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MahmoudZohdy.github.io/posts/practical_reverse_engineering/enumerate_loaded_drivers_every_10sec/</guid>
      <description>In this Blog I will explain my approach for solving one of the exercises from Practical Reverse Engineering Book, which is enumerating the loaded module list every 10 minutes.
So after searching for the method to get all loaded Drivers on the system, I found there is an easy way you can to do it from user-mode (1) but I to do it using kernel mode driver and I want it to be stable on all windows versions.</description>
    </item>
    
    <item>
      <title>Windows Internal</title>
      <link>https://MahmoudZohdy.github.io/wi/</link>
      <pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MahmoudZohdy.github.io/wi/</guid>
      <description> Asynchronous Procedure Calls (APC) Enumeration Loaded Drivers Enumeration </description>
    </item>
    
    <item>
      <title>Asynchronous Procedure Calls (APC) Enumeration</title>
      <link>https://MahmoudZohdy.github.io/posts/practical_reverse_engineering/apcenumeration/</link>
      <pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MahmoudZohdy.github.io/posts/practical_reverse_engineering/apcenumeration/</guid>
      <description>In this Blog I will explain my approach for solving one of the exercises from Practical Reverse Engineering Book, which is enumerating kernel/user Asynchronous Procedure Calls (APC) of a process.
So I started Reverse Engineering Some of the APC related functions, creating windows kernel driver that uses APC in different situation and use Windbg to add breakpoint on the APC callback functions to see how it is dispatched, plus Reading lots of blogs and documentation on how APC is working and how it is dispatched</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://MahmoudZohdy.github.io/aboutme/</link>
      <pubDate>Thu, 15 Jul 2021 19:57:14 +0200</pubDate>
      
      <guid>https://MahmoudZohdy.github.io/aboutme/</guid>
      <description>Bio A security Enthuse who loves Reverse Engineering, low level development and windows internal, i like to get my hands dirty digging deep into the technical details of both hardware and software devices, to get a better understanding of how things work.</description>
    </item>
    
    <item>
      <title>Reverse Engineering</title>
      <link>https://MahmoudZohdy.github.io/re/</link>
      <pubDate>Thu, 15 Jul 2021 19:57:14 +0200</pubDate>
      
      <guid>https://MahmoudZohdy.github.io/re/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
